{
  "api/LibGameAI.DecisionTrees.ActionNode.html": {
    "href": "api/LibGameAI.DecisionTrees.ActionNode.html",
    "title": "Class ActionNode | LibGameAI",
    "keywords": "Class ActionNode Namespace LibGameAI.DecisionTrees Assembly DecisionTrees.dll An action node in a decision tree. public class ActionNode : IDecisionTreeNode Inheritance object ActionNode Implements IDecisionTreeNode Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActionNode(Action) Create a new game action node. public ActionNode(Action gameAction) Parameters gameAction Action Delegate to function which will execute the actual game action. Methods Execute() Execute the game action. public void Execute() MakeDecision() An action node is always a leaf on the tree, so it will return itself. public IDecisionTreeNode MakeDecision() Returns IDecisionTreeNode Returns itself."
  },
  "api/LibGameAI.DecisionTrees.DecisionNode.html": {
    "href": "api/LibGameAI.DecisionTrees.DecisionNode.html",
    "title": "Class DecisionNode | LibGameAI",
    "keywords": "Class DecisionNode Namespace LibGameAI.DecisionTrees Assembly DecisionTrees.dll A decision node in a decision tree. public class DecisionNode : IDecisionTreeNode Inheritance object DecisionNode Implements IDecisionTreeNode Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DecisionNode(Func<bool>, IDecisionTreeNode, IDecisionTreeNode) Creates a new decision node. public DecisionNode(Func<bool> test, IDecisionTreeNode trueNode, IDecisionTreeNode falseNode) Parameters test Func<bool> Function which will make the true or false decision. trueNode IDecisionTreeNode DT node to return when the decision is true. falseNode IDecisionTreeNode DT node to return when the decision is false. Methods MakeDecision() Make a decision. public IDecisionTreeNode MakeDecision() Returns IDecisionTreeNode A DT node, which will depend wether the decision was true or false."
  },
  "api/LibGameAI.DecisionTrees.IDecisionTreeNode.html": {
    "href": "api/LibGameAI.DecisionTrees.IDecisionTreeNode.html",
    "title": "Interface IDecisionTreeNode | LibGameAI",
    "keywords": "Interface IDecisionTreeNode Namespace LibGameAI.DecisionTrees Assembly DecisionTrees.dll Represents a node in a decision tree. public interface IDecisionTreeNode Methods MakeDecision() Make a decision. IDecisionTreeNode MakeDecision() Returns IDecisionTreeNode A DT node, which will depend wether the decision was true or false."
  },
  "api/LibGameAI.DecisionTrees.RandomDecisionBehaviour.html": {
    "href": "api/LibGameAI.DecisionTrees.RandomDecisionBehaviour.html",
    "title": "Class RandomDecisionBehaviour | LibGameAI",
    "keywords": "Class RandomDecisionBehaviour Namespace LibGameAI.DecisionTrees Assembly DecisionTrees.dll Helper class which performs a random decision and maintains it during a specified duration and while the tree node containing it continues to be invoked every frame. public class RandomDecisionBehaviour Inheritance object RandomDecisionBehaviour Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RandomDecisionBehaviour(Func<float>, Func<float>, float, float) Creates a new random decision behaviour. public RandomDecisionBehaviour(Func<float> nextRandValFunc, Func<float> getTimeFunc, float timeoutDuration, float trueProb = 0.5) Parameters nextRandValFunc Func<float> A function which returns a random value between 0 and 1. getTimeFunc Func<float> A function which returns the current time. timeoutDuration float How many seconds before this decision times out. trueProb float Probability of a true decision (0.5f by default). Methods RandomDecision() Makes a true or false decision, or keeps the previous decision if the world state hasn't changed and the decision hasn't timed out. public bool RandomDecision() Returns bool True or false."
  },
  "api/LibGameAI.DecisionTrees.html": {
    "href": "api/LibGameAI.DecisionTrees.html",
    "title": "Namespace LibGameAI.DecisionTrees | LibGameAI",
    "keywords": "Namespace LibGameAI.DecisionTrees Classes ActionNode An action node in a decision tree. DecisionNode A decision node in a decision tree. RandomDecisionBehaviour Helper class which performs a random decision and maintains it during a specified duration and while the tree node containing it continues to be invoked every frame. Interfaces IDecisionTreeNode Represents a node in a decision tree."
  },
  "api/LibGameAI.FSMs.State.html": {
    "href": "api/LibGameAI.FSMs.State.html",
    "title": "Class State | LibGameAI",
    "keywords": "Class State Namespace LibGameAI.FSMs Assembly FSMs.dll A FSM state. public class State Inheritance object State Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors State(string, Action, Action, Action) Create a new state. public State(string name, Action entryActions, Action stateActions, Action exitActions) Parameters name string Name of the FSM state. entryActions Action Actions to perform when entering this state. stateActions Action Actions to perform while in this state. exitActions Action Actions to perform when exiting this state. Properties EntryActions Actions to perform when entering this state. public Action EntryActions { get; } Property Value Action ExitActions Actions to perform when exiting this state. public Action ExitActions { get; } Property Value Action Name Name of the FSM state. public string Name { get; } Property Value string StateActions Actions to perform while in this state. public Action StateActions { get; } Property Value Action Transitions Public property exposing the transitions associated with this state. public IEnumerable<Transition> Transitions { get; } Property Value IEnumerable<Transition> Methods AddTransition(Transition) Add a transition from this state to another state public void AddTransition(Transition transition) Parameters transition Transition Transition to another state."
  },
  "api/LibGameAI.FSMs.StateMachine.html": {
    "href": "api/LibGameAI.FSMs.StateMachine.html",
    "title": "Class StateMachine | LibGameAI",
    "keywords": "Class StateMachine Namespace LibGameAI.FSMs Assembly FSMs.dll A finite state machine. public class StateMachine Inheritance object StateMachine Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StateMachine(State) Create a new FSM. public StateMachine(State initialState) Parameters initialState State Initial state. Methods Update() Update the FSM and return the actions to perform. public Action Update() Returns Action Actions to perform."
  },
  "api/LibGameAI.FSMs.Transition.html": {
    "href": "api/LibGameAI.FSMs.Transition.html",
    "title": "Class Transition | LibGameAI",
    "keywords": "Class Transition Namespace LibGameAI.FSMs Assembly FSMs.dll A transition between states. public class Transition Inheritance object Transition Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Transition(Func<bool>, Action, State) Create a new transition. public Transition(Func<bool> condition, Action actions, State targetState) Parameters condition Func<bool> Condition for triggering this transition. actions Action Actions associated with this transition. targetState State Target state for this transition. Properties Actions Actions associated with this transition. public Action Actions { get; } Property Value Action TargetState Target state for this transition. public State TargetState { get; } Property Value State Methods IsTriggered() Is this transition triggered? public bool IsTriggered() Returns bool true if transition is triggered, false otherwise."
  },
  "api/LibGameAI.FSMs.html": {
    "href": "api/LibGameAI.FSMs.html",
    "title": "Namespace LibGameAI.FSMs | LibGameAI",
    "keywords": "Namespace LibGameAI.FSMs Classes State A FSM state. StateMachine A finite state machine. Transition A transition between states."
  },
  "api/LibGameAI.NGrams.ActionFrequency-1.html": {
    "href": "api/LibGameAI.NGrams.ActionFrequency-1.html",
    "title": "Class ActionFrequency<T> | LibGameAI",
    "keywords": "Class ActionFrequency<T> Namespace LibGameAI.NGrams Assembly NGrams.dll Record containing actions and their frequencies. public class ActionFrequency<T> Type Parameters T The type of the actions. Inheritance object ActionFrequency<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActionFrequency() Creates new action frequency data record. public ActionFrequency() Properties BestAction The most likely/frequent action. public T BestAction { get; } Property Value T Total Number of times the sequence associated to these actions has been executed. public int Total { get; } Property Value int Methods IncrementFrequency(T) Increment the frequency of the specified action. public void IncrementFrequency(T action) Parameters action T The action for which the frequency will be incremented."
  },
  "api/LibGameAI.NGrams.HierarchNGram-1.html": {
    "href": "api/LibGameAI.NGrams.HierarchNGram-1.html",
    "title": "Class HierarchNGram<T> | LibGameAI",
    "keywords": "Class HierarchNGram<T> Namespace LibGameAI.NGrams Assembly NGrams.dll Hierarchical N-Gram. public class HierarchNGram<T> : INGram<T> Type Parameters T The type of the actions. Inheritance object HierarchNGram<T> Implements INGram<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HierarchNGram(int, int) Creates a new hierarchical N-Gram. public HierarchNGram(int nValue, int threshold) Parameters nValue int The N in N-Gram (window size + 1). threshold int Minimum number of observations for a specific N-Gram to return a prediction. Properties NValue The N in N-Gram (window size + 1). public int NValue { get; } Property Value int Methods GetMostLikely(IReadOnlyList<T>) Get the most likely action given a sequence of actions. public T GetMostLikely(IReadOnlyList<T> actions) Parameters actions IReadOnlyList<T> The actions list, which should be at least of size 1. Returns T The most likely action for the given a sequence of actions. RegisterSequence(IReadOnlyList<T>) Register a sequence of actions. public void RegisterSequence(IReadOnlyList<T> actions) Parameters actions IReadOnlyList<T> The actions list, which should be at least of size 1."
  },
  "api/LibGameAI.NGrams.INGram-1.html": {
    "href": "api/LibGameAI.NGrams.INGram-1.html",
    "title": "Interface INGram<T> | LibGameAI",
    "keywords": "Interface INGram<T> Namespace LibGameAI.NGrams Assembly NGrams.dll Interface for concrete N-Gram implementations. public interface INGram<T> Type Parameters T The type of the actions. Properties NValue The N in N-Gram (window size + 1). int NValue { get; } Property Value int Methods GetMostLikely(IReadOnlyList<T>) Get the most likely action given a sequence of actions. T GetMostLikely(IReadOnlyList<T> actions) Parameters actions IReadOnlyList<T> The actions list. Returns T The most likely action for the given a sequence of actions. RegisterSequence(IReadOnlyList<T>) Register a sequence of actions. void RegisterSequence(IReadOnlyList<T> actions) Parameters actions IReadOnlyList<T> The actions list."
  },
  "api/LibGameAI.NGrams.NGram-1.html": {
    "href": "api/LibGameAI.NGrams.NGram-1.html",
    "title": "Class NGram<T> | LibGameAI",
    "keywords": "Class NGram<T> Namespace LibGameAI.NGrams Assembly NGrams.dll A regular N-Gram. public class NGram<T> : INGram<T> Type Parameters T The type of the actions. Inheritance object NGram<T> Implements INGram<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NGram(int) Creates a new N-Gram. public NGram(int nValue) Parameters nValue int The N in N-Gram (window size + 1). Properties NValue The N in N-Gram (window size + 1). public int NValue { get; } Property Value int Methods GetActionsFrequency(IReadOnlyCollection<T>) Return the number of times the given sequence of actions has been seen. public int GetActionsFrequency(IReadOnlyCollection<T> actions) Parameters actions IReadOnlyCollection<T> Sequence of actions, which must of size N-1. Returns int Number of times the given sequence of actions has been seen. GetMostLikely(IReadOnlyList<T>) Get the most likely action given a sequence of actions. public T GetMostLikely(IReadOnlyList<T> actions) Parameters actions IReadOnlyList<T> The actions list, which should be at least of size N-1. Returns T The most likely action for the given a sequence of actions. RegisterSequence(IReadOnlyList<T>) Register a sequence of actions. public void RegisterSequence(IReadOnlyList<T> actions) Parameters actions IReadOnlyList<T> The actions list, which should be at least of size N. SequenceToString(IEnumerable<T>) Converts a sequence of objects to a string. public static string SequenceToString(IEnumerable<T> actions) Parameters actions IEnumerable<T> Sequence of objects. Returns string String representing sequence of objects."
  },
  "api/LibGameAI.NGrams.html": {
    "href": "api/LibGameAI.NGrams.html",
    "title": "Namespace LibGameAI.NGrams | LibGameAI",
    "keywords": "Namespace LibGameAI.NGrams Classes ActionFrequency<T> Record containing actions and their frequencies. HierarchNGram<T> Hierarchical N-Gram. NGram<T> A regular N-Gram. Interfaces INGram<T> Interface for concrete N-Gram implementations."
  },
  "api/LibGameAI.NaiveBayes.Attrib.html": {
    "href": "api/LibGameAI.NaiveBayes.Attrib.html",
    "title": "Class Attrib | LibGameAI",
    "keywords": "Class Attrib Namespace LibGameAI.NaiveBayes Assembly NaiveBayes.dll public class Attrib Inheritance object Attrib Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Attrib(string, IEnumerable<string>) public Attrib(string name, IEnumerable<string> values) Parameters name string values IEnumerable<string> Properties Name public string Name { get; } Property Value string Values public ICollection<string> Values { get; } Property Value ICollection<string>"
  },
  "api/LibGameAI.NaiveBayes.NaiveBayesClassifier.html": {
    "href": "api/LibGameAI.NaiveBayes.NaiveBayesClassifier.html",
    "title": "Class NaiveBayesClassifier | LibGameAI",
    "keywords": "Class NaiveBayesClassifier Namespace LibGameAI.NaiveBayes Assembly NaiveBayes.dll public class NaiveBayesClassifier Inheritance object NaiveBayesClassifier Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NaiveBayesClassifier(IEnumerable<string>, IEnumerable<Attrib>) public NaiveBayesClassifier(IEnumerable<string> labels, IEnumerable<Attrib> attributes) Parameters labels IEnumerable<string> attributes IEnumerable<Attrib> Methods Predict(IDictionary<Attrib, string>) public string Predict(IDictionary<Attrib, string> attribValues) Parameters attribValues IDictionary<Attrib, string> Returns string Update(string, IDictionary<Attrib, string>) public void Update(string label, IDictionary<Attrib, string> attribValues) Parameters label string attribValues IDictionary<Attrib, string>"
  },
  "api/LibGameAI.NaiveBayes.html": {
    "href": "api/LibGameAI.NaiveBayes.html",
    "title": "Namespace LibGameAI.NaiveBayes | LibGameAI",
    "keywords": "Namespace LibGameAI.NaiveBayes Classes Attrib NaiveBayesClassifier"
  },
  "api/LibGameAI.PCG.CA2D.html": {
    "href": "api/LibGameAI.PCG.CA2D.html",
    "title": "Class CA2D | LibGameAI",
    "keywords": "Class CA2D Namespace LibGameAI.PCG Assembly PCG.dll A 2D discrete cellular automaton (CA). public class CA2D Inheritance object CA2D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Instances of this class represent a cellular automaton, but the class also provides CA-related functionality via static methods for those interested in directly handling the CA state. Constructors CA2D(ICA2DRule, int, int, bool, int) Create a new 2D discrete cellular automaton. public CA2D(ICA2DRule rule, int xDim, int yDim, bool toroidal, int nonToroidalBorderCells = 0) Parameters rule ICA2DRule Transition rule governing the CA. xDim int Width of the CA. yDim int Height of the CA. toroidal bool Is the CA toroidal? nonToroidalBorderCells int The value of off-grid cells in case the CA is not toroidal. Properties this[int, int] A read-only indexer returning the value of the CA cell at the specified indexes. public int this[int x, int y] { get; } Parameters x int Horizontal position of the cell. y int Vertical position of the cell. Property Value int Value of the CA cell at the specified indexes. NonToroidalOffGridCells What is the value of off-grid cells in case the CA is not toroidal? public int NonToroidalOffGridCells { get; } Property Value int Toroidal Is the CA toroidal? public bool Toroidal { get; } Property Value bool XDim Width of the CA. public int XDim { get; } Property Value int YDim Height of the CA. public int YDim { get; } Property Value int Methods CountNeighbors(int, int, int, Neighborhood, int, bool) Count neighbors with a specific value around a given cell. public int CountNeighbors(int x, int y, int radius, Neighborhood neighType = Neighborhood.Moore, int neighValue = 1, bool countSelf = false) Parameters x int Horizontal position of the cell. y int Vertical position of the cell. radius int Neighborhood radius to search. neighType Neighborhood Neighborhood type. neighValue int Count neighbors with this value. countSelf bool Count self? Returns int Number of neighbors with a specific value around a given cell. CountNeighbors(int[], int, int, int, int, bool, int, int, int, bool, Neighborhood) Count neighbors with a specific value around a given cell. public static int CountNeighbors(int[] map, int xDim, int yDim, int xCell, int yCell, bool toroidal = true, int nonToroidalOffGridCells = 0, int radius = 1, int neighValue = 1, bool countSelf = false, Neighborhood neighType = Neighborhood.Moore) Parameters map int[] An integer array representing a grid in row-major format. xDim int Grid width. yDim int Grid height. xCell int Horizontal cell position. yCell int Vertical cell position. toroidal bool Consider the grid toroidal? nonToroidalOffGridCells int Value of the off-grid cells in case the grid is not toroidal. radius int Neighborhood radius. neighValue int Value of neighbors to count. countSelf bool Count central cell? neighType Neighborhood Neighborhood type. Returns int The number of neighbors with a specific value around a given cell. DoStep() Perform a step in the CA evolution. public void DoStep() Exceptions InvalidOperationException Exception thrown if the CA is not initialized. InitExact(int[,]) Initialize the CA with the exact state given. public void InitExact(int[,] initialState) Parameters initialState int[,] The state with which to initialize the CA. Exceptions ArgumentException Exception thrown if the size of the given initial state is different from the size of the CA grid. InitExact(int[]) Initialize the CA with the exact state given. public void InitExact(int[] initialState) Parameters initialState int[] The state with which to initialize the CA in row-major order. Exceptions ArgumentException Exception thrown if the size of given initial state is different from the size of the CA grid. InitFunc(Func<int, int, int>) Initialize the CA using a delegate. public void InitFunc(Func<int, int, int> initializer) Parameters initializer Func<int, int, int> Delegate used to initialize the CA, which should accept the x and y cell position and return its value. InitRandom(int[], float[], Func<float>) Randomly initialize the CA with an external random number generator. public void InitRandom(int[] values, float[] probabilities, Func<float> nextFloat) Parameters values int[] Possible values with which to initialize the cells. probabilities float[] Probabilities of each value being assigned. If not given, each value will be assigned with equal probability. nextFloat Func<float> Delegate which will return a random float between 0 and 1. InitRandom(int[], float[], int?) Randomly initialize the CA using the system's random number generator. public void InitRandom(int[] values, float[] probabilities = null, int? seed = null) Parameters values int[] Possible values with which to initialize the cells. probabilities float[] Probabilities of each value being assigned. If not given, each value will be assigned with equal probability. seed int? Seed for the random number generator. If not given, generator will be randomly initialized. RandomFill(int[], int[], float[], Func<float>) Randomly fill the map with the given values with the specified probabilities using a delegate method for random number generation. public static void RandomFill(int[] map, int[] values, float[] probabilities, Func<float> nextFloat) Parameters map int[] Integer array to fill. values int[] Values with which to fill the array. probabilities float[] Probabilities associated with each value. nextFloat Func<float> Delegate which will return a random float between 0 and 1. Exceptions InvalidOperationException Thrown if values and probabilities have different lengths."
  },
  "api/LibGameAI.PCG.CA2DBinaryRule.html": {
    "href": "api/LibGameAI.PCG.CA2DBinaryRule.html",
    "title": "Class CA2DBinaryRule | LibGameAI",
    "keywords": "Class CA2DBinaryRule Namespace LibGameAI.PCG Assembly PCG.dll A transition rule for discrete binary deterministic 2D cellular automata. public class CA2DBinaryRule : ICA2DRule Inheritance object CA2DBinaryRule Implements ICA2DRule Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks A rule is defined as a string as follows: <N,R/{values-for-survival}/{values-for-birth}> Where: N represents the neighborhood type (M for Moore, V for Von Neumann, H for Hexagonal). R indicates the radius of the neighborhood. {values-for-survival} and {values-for-birth} are comma-separated lists where values can be individual numbers or ranges denoted by a start and end number separated by a hyphen (-). A hyphen at the start or end indicates a range extending from zero or up to the maximum possible number of neighbors, respectively. Examples: M,1/2-5/3,6-8 Neighborhood: Moore Radius: 1 Survival: A cell survives if it has between 2 and 5 live neighbors. Birth: A cell is born if it has exactly 3 live neighbors or between 6 and 8 live neighbors. `V,2/-/1-4 Neighborhood: Von Neumann Radius: 2 Survival: No specific survival rules; the hyphen implies all possibilities are valid, so live cells will always survive. Birth: A cell is born if it has between 1 and 4 live neighbors. H,3/0,2,4-6/10- Neighborhood: Hexagonal Radius: 3 Survival: A cell survives if it has 0, 2, or between 4 and 6 live neighbors. Birth: Cells are born if they have 10 or more live neighbors. M,2/1,10-/-3,7-9 Neighborhood: Moore Radius: 2 Survival: A cell survives if it has exactly 1 live neighbor or more than 10 live neighbors. Birth: A cell is born if it has between 0 and 3 live neighbors or between live 7 and 9 neighbors. Constructors CA2DBinaryRule(string) Create a new transition rule defined in the given string. public CA2DBinaryRule(string ruleString) Parameters ruleString string A string defining the rule. Properties BirthRules Birth rules. public ISet<int> BirthRules { get; } Property Value ISet<int> NeighborhoodType Neighborhood type. public Neighborhood NeighborhoodType { get; } Property Value Neighborhood Radius Neighborhood radius. public int Radius { get; } Property Value int SurvivalRules Survival rules. public ISet<int> SurvivalRules { get; } Property Value ISet<int> Methods ProcessRule(CA2D, int, int) Process the specified CA cell with this rule. public int ProcessRule(CA2D ca, int x, int y) Parameters ca CA2D The cellular automaton. x int Horizontal cell position. y int Vertical cell position. Returns int New value for the specified CA cell after applying this rule."
  },
  "api/LibGameAI.PCG.ICA2DRule.html": {
    "href": "api/LibGameAI.PCG.ICA2DRule.html",
    "title": "Interface ICA2DRule | LibGameAI",
    "keywords": "Interface ICA2DRule Namespace LibGameAI.PCG Assembly PCG.dll Interface for discrete 2D CA rules. public interface ICA2DRule Methods ProcessRule(CA2D, int, int) Process rule. int ProcessRule(CA2D ca, int x, int y) Parameters ca CA2D The cellular automaton. x int Cell horizontal position. y int Cell vertical position. Returns int The new cell value after applying the rule."
  },
  "api/LibGameAI.PCG.Landscape.html": {
    "href": "api/LibGameAI.PCG.Landscape.html",
    "title": "Class Landscape | LibGameAI",
    "keywords": "Class Landscape Namespace LibGameAI.PCG Assembly PCG.dll public static class Landscape Inheritance object Landscape Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DiamondSquare(float[,], float, float, Func<float>) public static void DiamondSquare(float[,] landscape, float maxInitHeight, float roughness, Func<float> randFloat) Parameters landscape float[,] maxInitHeight float roughness float randFloat Func<float> FaultModifier(float[,], float, Func<float>, float) public static void FaultModifier(float[,] landscape, float depth, Func<float> randFloat, float decreaseDistance = 0) Parameters landscape float[,] depth float randFloat Func<float> decreaseDistance float Sandpile(float[,], float, float, float, float, bool, bool, Func<int, int>, Func<double>, (int x, int y)[]) public static void Sandpile(float[,] landscape, float threshold, float increment, float decrement, float grainDropDensity, bool staticDrop, bool stochastic, Func<int, int> randInt, Func<double> randDouble, (int x, int y)[] neighs = null) Parameters landscape float[,] threshold float increment float decrement float grainDropDensity float staticDrop bool stochastic bool randInt Func<int, int> randDouble Func<double> neighs (int x, int y)[] ThermalErosion(float[,], float) public static void ThermalErosion(float[,] landscape, float impact) Parameters landscape float[,] impact float"
  },
  "api/LibGameAI.PCG.Noise.html": {
    "href": "api/LibGameAI.PCG.Noise.html",
    "title": "Class Noise | LibGameAI",
    "keywords": "Class Noise Namespace LibGameAI.PCG Assembly PCG.dll public static class Noise Inheritance object Noise Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods MPD(float[], float, Func<float>) Midpoint displacement algorithm for 2D landscapes. public static void MPD(float[] heights, float roughness, Func<float> nextFloat) Parameters heights float[] Array to fill with landscape heights, zero-centered in average. roughness float Landscape roughness, between 0 (flat landscape) and 1 (very rough landscape). nextFloat Func<float> Function which should return a random float between 0 and 1."
  },
  "api/LibGameAI.PCG.html": {
    "href": "api/LibGameAI.PCG.html",
    "title": "Namespace LibGameAI.PCG | LibGameAI",
    "keywords": "Namespace LibGameAI.PCG Classes CA2D A 2D discrete cellular automaton (CA). CA2DBinaryRule A transition rule for discrete binary deterministic 2D cellular automata. Landscape Noise Interfaces ICA2DRule Interface for discrete 2D CA rules."
  },
  "api/LibGameAI.PRNG.LCG48.html": {
    "href": "api/LibGameAI.PRNG.LCG48.html",
    "title": "Class LCG48 | LibGameAI",
    "keywords": "Class LCG48 Namespace LibGameAI.PRNG Assembly PRNG.dll C# reimplementation of Java's PRNG, a linear congruential generator (LCG). public class LCG48 : Random Inheritance object Random LCG48 Inherited Members Random.Next(int) Random.NextBytes(Span<byte>) Random.NextDouble() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Useful links: Linear congruential generator - Wikipedia Implementation of this particular LCG in OpenCL Java's implementation Java's documentation of the Random class .NET Core implementation of the Random class .NET Framework implementation of the Random class Documentation on how to extend the Random class Constructors LCG48() public LCG48() LCG48(int) public LCG48(int seed) Parameters seed int LCG48(long) public LCG48(long seed) Parameters seed long Methods Next() Returns a non-negative random integer. public override int Next() Returns int A 32-bit signed integer that is greater than or equal to 0 and less than MaxValue. Next(int, int) Returns a random integer that is within a specified range. public override int Next(int minValue, int maxValue) Parameters minValue int The inclusive lower bound of the random number returned. maxValue int The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue. Returns int A 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of return values includes minValue but not maxValue. If minValue equals maxValue, minValue is returned. Exceptions ArgumentOutOfRangeException minValue is greater than maxValue. NextBytes(byte[]) Fills the elements of a specified array of bytes with random numbers. public override void NextBytes(byte[] buffer) Parameters buffer byte[] An array of bytes to contain random numbers. Exceptions ArgumentNullException buffer is null. Sample() Returns a random floating-point number between 0.0 and 1.0. protected override double Sample() Returns double A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0."
  },
  "api/LibGameAI.PRNG.Randu.html": {
    "href": "api/LibGameAI.PRNG.Randu.html",
    "title": "Class Randu | LibGameAI",
    "keywords": "Class Randu Namespace LibGameAI.PRNG Assembly PRNG.dll Example of a bad random number generator for testing purposes. public class Randu : Random Inheritance object Random Randu Inherited Members Random.Next(int) Random.NextBytes(Span<byte>) Random.NextDouble() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Useful links: RANDU - Wikipedia A bad implementation in C of a bad algorithm Implementation of the RANDU random number generator in Java .NET Core implementation of the Random class .NET Framework implementation of the Random class Documentation on how to extend the Random class Constructors Randu() public Randu() Randu(int) public Randu(int seed) Parameters seed int Methods Next() Returns a non-negative random integer. public override int Next() Returns int A 32-bit signed integer that is greater than or equal to 0 and less than MaxValue. Next(int, int) Returns a random integer that is within a specified range. public override int Next(int minValue, int maxValue) Parameters minValue int The inclusive lower bound of the random number returned. maxValue int The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue. Returns int A 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of return values includes minValue but not maxValue. If minValue equals maxValue, minValue is returned. Exceptions ArgumentOutOfRangeException minValue is greater than maxValue. NextBytes(byte[]) Fills the elements of a specified array of bytes with random numbers. public override void NextBytes(byte[] buffer) Parameters buffer byte[] An array of bytes to contain random numbers. Exceptions ArgumentNullException buffer is null. Sample() Returns a random floating-point number between 0.0 and 1.0. protected override double Sample() Returns double A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0."
  },
  "api/LibGameAI.PRNG.XorShift128.html": {
    "href": "api/LibGameAI.PRNG.XorShift128.html",
    "title": "Class XorShift128 | LibGameAI",
    "keywords": "Class XorShift128 Namespace LibGameAI.PRNG Assembly PRNG.dll A 128-bit implementation of a XorShift pseudo-random number generator. public class XorShift128 : Random Inheritance object Random XorShift128 Inherited Members Random.Next(int) Random.NextBytes(Span<byte>) Random.NextDouble() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Useful links: Xorshift - Wikipedia Implementation of this particular XorShift in OpenCL .NET Core implementation of the Random class .NET Framework implementation of the Random class Documentation on how to extend the Random class Constructors XorShift128() public XorShift128() XorShift128(int) public XorShift128(int seed) Parameters seed int XorShift128(long) public XorShift128(long seed) Parameters seed long Methods Next() Returns a non-negative random integer. public override int Next() Returns int A 32-bit signed integer that is greater than or equal to 0 and less than MaxValue. Next(int, int) Returns a random integer that is within a specified range. public override int Next(int minValue, int maxValue) Parameters minValue int The inclusive lower bound of the random number returned. maxValue int The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue. Returns int A 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of return values includes minValue but not maxValue. If minValue equals maxValue, minValue is returned. Exceptions ArgumentOutOfRangeException minValue is greater than maxValue. NextBytes(byte[]) Fills the elements of a specified array of bytes with random numbers. public override void NextBytes(byte[] buffer) Parameters buffer byte[] An array of bytes to contain random numbers. Exceptions ArgumentNullException buffer is null. Sample() Returns a random floating-point number between 0.0 and 1.0. protected override double Sample() Returns double A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0."
  },
  "api/LibGameAI.PRNG.html": {
    "href": "api/LibGameAI.PRNG.html",
    "title": "Namespace LibGameAI.PRNG | LibGameAI",
    "keywords": "Namespace LibGameAI.PRNG Classes LCG48 C# reimplementation of Java's PRNG, a linear congruential generator (LCG). Randu Example of a bad random number generator for testing purposes. XorShift128 A 128-bit implementation of a XorShift pseudo-random number generator."
  },
  "api/LibGameAI.PathFinding.AStarPathFinder.html": {
    "href": "api/LibGameAI.PathFinding.AStarPathFinder.html",
    "title": "Class AStarPathFinder | LibGameAI",
    "keywords": "Class AStarPathFinder Namespace LibGameAI.PathFinding Assembly PathFinding.dll A path finder implemented with the A* algorithm. public class AStarPathFinder : IPathFinder Inheritance object AStarPathFinder Implements IPathFinder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Optimizations to be done (some are code-related with others): TODO Use a heap/priority queue (priority heap) data structure for the open and closed nodes. TODO Either make NodeRecord structs (and update surrounding code appropriately) or use an object pool of NodeRecords. TODO Avoid always getting node record from the dictionary, just pull it once onto a local variable and use that. TODO Reuse the heuristic value from previously existing node records. Constructors AStarPathFinder(Func<int, float>, bool) Create a new A* path finder. public AStarPathFinder(Func<int, float> heuristics, bool earlyExit = false) Parameters heuristics Func<int, float> Heuristic function to use. earlyExit bool Stop as soon as goal is found in open list with the possibility of getting a costlier path? Properties ClosedNodes public IEnumerable<int> ClosedNodes { get; } Property Value IEnumerable<int> OpenNodes public IEnumerable<int> OpenNodes { get; } Property Value IEnumerable<int> Methods FindPath(IGraph, int, int) Find a path between start and goal nodes. public IEnumerable<IConnection> FindPath(IGraph graph, int start, int goal) Parameters graph IGraph Graph where to perform search. start int Start node. goal int Goal node. Returns IEnumerable<IConnection> An enumerable containing the connections that constitute a path from start to goal."
  },
  "api/LibGameAI.PathFinding.Connection.html": {
    "href": "api/LibGameAI.PathFinding.Connection.html",
    "title": "Struct Connection | LibGameAI",
    "keywords": "Struct Connection Namespace LibGameAI.PathFinding Assembly PathFinding.dll public struct Connection : IConnection Implements IConnection Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Connection(float, int, int) public Connection(float cost, int fromNode, int toNode) Parameters cost float fromNode int toNode int Properties Cost public readonly float Cost { get; } Property Value float FromNode public readonly int FromNode { get; } Property Value int ToNode public readonly int ToNode { get; } Property Value int"
  },
  "api/LibGameAI.PathFinding.DijkstraPathFinder.html": {
    "href": "api/LibGameAI.PathFinding.DijkstraPathFinder.html",
    "title": "Class DijkstraPathFinder | LibGameAI",
    "keywords": "Class DijkstraPathFinder Namespace LibGameAI.PathFinding Assembly PathFinding.dll A path finder implemented with the Dijkstra algorithm. Always finds the shortest path. public class DijkstraPathFinder : IPathFinder Inheritance object DijkstraPathFinder Implements IPathFinder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Optimizations to be done (some are code-related with others): TODO Use a heap/priority queue (priority heap) data structure for the open and closed nodes. TODO Either make NodeRecord structs (and update surrounding code appropriately) or use an object pool of NodeRecords. TODO Avoid always getting node record from the dictionary, just pull it once onto a local variable and use that. Constructors DijkstraPathFinder() Create a new Dijkstra shortest path finder. public DijkstraPathFinder() Properties ClosedNodes public IEnumerable<int> ClosedNodes { get; } Property Value IEnumerable<int> OpenNodes public IEnumerable<int> OpenNodes { get; } Property Value IEnumerable<int> Methods FindPath(IGraph, int, int) Find shortest path between start and goal nodes. public IEnumerable<IConnection> FindPath(IGraph graph, int start, int goal) Parameters graph IGraph Graph where to perform search. start int Start node. goal int Goal node. Returns IEnumerable<IConnection> An enumerable containing the connections that constitute the shortest path from start to goal."
  },
  "api/LibGameAI.PathFinding.Graph.html": {
    "href": "api/LibGameAI.PathFinding.Graph.html",
    "title": "Class Graph | LibGameAI",
    "keywords": "Class Graph Namespace LibGameAI.PathFinding Assembly PathFinding.dll public class Graph : IGraph Inheritance object Graph Implements IGraph Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Graph(IList<IEnumerable<IConnection>>) Create new graph using an adjacency list. public Graph(IList<IEnumerable<IConnection>> connections) Parameters connections IList<IEnumerable<IConnection>> Adjacency list with which to create graph. Graph(float[,]) Create new graph using an adjacency matrix. public Graph(float[,] adjMatrix) Parameters adjMatrix float[,] Adjacency matrix with which to create graph. Methods GetConnections(int) Get all outgoing connections for the given node. public IEnumerable<IConnection> GetConnections(int fromNode) Parameters fromNode int A node in the graph. Returns IEnumerable<IConnection> All outgoing connections for the given node."
  },
  "api/LibGameAI.PathFinding.IConnection.html": {
    "href": "api/LibGameAI.PathFinding.IConnection.html",
    "title": "Interface IConnection | LibGameAI",
    "keywords": "Interface IConnection Namespace LibGameAI.PathFinding Assembly PathFinding.dll public interface IConnection Properties Cost float Cost { get; } Property Value float FromNode int FromNode { get; } Property Value int ToNode int ToNode { get; } Property Value int"
  },
  "api/LibGameAI.PathFinding.IGraph.html": {
    "href": "api/LibGameAI.PathFinding.IGraph.html",
    "title": "Interface IGraph | LibGameAI",
    "keywords": "Interface IGraph Namespace LibGameAI.PathFinding Assembly PathFinding.dll public interface IGraph Methods GetConnections(int) IEnumerable<IConnection> GetConnections(int fromNode) Parameters fromNode int Returns IEnumerable<IConnection>"
  },
  "api/LibGameAI.PathFinding.IPathFinder.html": {
    "href": "api/LibGameAI.PathFinding.IPathFinder.html",
    "title": "Interface IPathFinder | LibGameAI",
    "keywords": "Interface IPathFinder Namespace LibGameAI.PathFinding Assembly PathFinding.dll public interface IPathFinder Properties ClosedNodes IEnumerable<int> ClosedNodes { get; } Property Value IEnumerable<int> OpenNodes IEnumerable<int> OpenNodes { get; } Property Value IEnumerable<int> Methods FindPath(IGraph, int, int) IEnumerable<IConnection> FindPath(IGraph graph, int start, int goal) Parameters graph IGraph start int goal int Returns IEnumerable<IConnection>"
  },
  "api/LibGameAI.PathFinding.html": {
    "href": "api/LibGameAI.PathFinding.html",
    "title": "Namespace LibGameAI.PathFinding | LibGameAI",
    "keywords": "Namespace LibGameAI.PathFinding Classes AStarPathFinder A path finder implemented with the A* algorithm. DijkstraPathFinder A path finder implemented with the Dijkstra algorithm. Always finds the shortest path. Graph Structs Connection Interfaces IConnection IGraph IPathFinder"
  },
  "api/LibGameAI.QRNG.Halton.html": {
    "href": "api/LibGameAI.QRNG.Halton.html",
    "title": "Class Halton | LibGameAI",
    "keywords": "Class Halton Namespace LibGameAI.QRNG Assembly QRNG.dll public class Halton : Random Inheritance object Random Halton Inherited Members Random.Next(int) Random.NextBytes(Span<byte>) Random.NextDouble() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Halton(int, bool) public Halton(int basePrime, bool skipFirstN = true) Parameters basePrime int skipFirstN bool Methods Next() Returns a non-negative random integer. public override int Next() Returns int A 32-bit signed integer that is greater than or equal to 0 and less than MaxValue. Next(int, int) Returns a random integer that is within a specified range. public override int Next(int minValue, int maxValue) Parameters minValue int The inclusive lower bound of the random number returned. maxValue int The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue. Returns int A 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of return values includes minValue but not maxValue. If minValue equals maxValue, minValue is returned. Exceptions ArgumentOutOfRangeException minValue is greater than maxValue. NextBytes(byte[]) Fills the elements of a specified array of bytes with random numbers. public override void NextBytes(byte[] buffer) Parameters buffer byte[] An array of bytes to contain random numbers. Exceptions ArgumentNullException buffer is null. Sample() Returns a random floating-point number between 0.0 and 1.0. protected override double Sample() Returns double A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0. Sequence(int, int) public static double Sequence(int basePrime, int index) Parameters basePrime int index int Returns double"
  },
  "api/LibGameAI.QRNG.html": {
    "href": "api/LibGameAI.QRNG.html",
    "title": "Namespace LibGameAI.QRNG | LibGameAI",
    "keywords": "Namespace LibGameAI.QRNG Classes Halton"
  },
  "api/LibGameAI.Util.ClassManager-1.html": {
    "href": "api/LibGameAI.Util.ClassManager-1.html",
    "title": "Class ClassManager<T> | LibGameAI",
    "keywords": "Class ClassManager<T> Namespace LibGameAI.Util Assembly Util.dll Singleton class used for finding and keeping a record of concrete classes of a given generic type. public class ClassManager<T> Type Parameters T Inheritance object ClassManager<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ClassNames Array of class names. public string[] ClassNames { get; } Property Value string[] Names of known classes of type T. Instance Returns the singleton instance of this class. public static ClassManager<T> Instance { get; } Property Value ClassManager<T> The singleton instance of this class. Methods FilterTypes(Func<Type, bool>) Filter out types that are not of interest to the client. public ClassManager<T> FilterTypes(Func<Type, bool> filter) Parameters filter Func<Type, bool> Filter to apply, returns true if class is to keep, or false otherwise. Returns ClassManager<T> This instance, for use in fluent syntax. GetNameFromType(Type) Get name from type. public string GetNameFromType(Type type) Parameters type Type Type of class. Returns string Name of class. GetTypeFromName(string) Get class type from class name. public Type GetTypeFromName(string name) Parameters name string Name of class. Returns Type The class's type. ReplaceNames(Func<string, string>) Replace default names with which the classes are known. public ClassManager<T> ReplaceNames(Func<string, string> replacer) Parameters replacer Func<string, string> Delegate to perform name replacement. Returns ClassManager<T> This instance, for use in fluent syntax."
  },
  "api/LibGameAI.Util.ListPlusOneWrapper-1.html": {
    "href": "api/LibGameAI.Util.ListPlusOneWrapper-1.html",
    "title": "Struct ListPlusOneWrapper<T> | LibGameAI",
    "keywords": "Struct ListPlusOneWrapper<T> Namespace LibGameAI.Util Assembly Util.dll An efficient wrapper for a list plus one element. public struct ListPlusOneWrapper<T> : IReadOnlyList<T>, IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable Type Parameters T Type of items in the collection. Implements IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ListPlusOneWrapper(IReadOnlyList<T>, T) Create a new wrapper for a list plus one element. public ListPlusOneWrapper(IReadOnlyList<T> list, T plusOne) Parameters list IReadOnlyList<T> List to be wrapped. plusOne T Extra element to apparently add to the list. Properties Count Number of items in the list (equal to the number of items in the wrapped list plus one). public readonly int Count { get; } Property Value int this[int] Gets the element at the specified index. public T this[int index] { get; } Parameters index int The zero-based index of the element to get. Property Value T The element at the specified index. Methods GetEnumerator() Returns an enumerator that iterates through the wrapped list plus the additional element. public IEnumerator<T> GetEnumerator() Returns IEnumerator<T> An enumerator that can be used to iterate through the list plus the additional element."
  },
  "api/LibGameAI.Util.MMath.html": {
    "href": "api/LibGameAI.Util.MMath.html",
    "title": "Class MMath | LibGameAI",
    "keywords": "Class MMath Namespace LibGameAI.Util Assembly Util.dll Useful math functions. public static class MMath Inheritance object MMath Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CumSum(float[]) Return cumulative sum of given vector. public static float[] CumSum(float[] vector) Parameters vector float[] Returns float[] A new vector with the cumulative sum of the input vector. IsPrime(int) Check whether an integer is prime or not. public static bool IsPrime(int n) Parameters n int Integer to check for primality. Returns bool True if integer is prime, false otherwise. Remarks Basic implementation as described in Wikipedia. Normalize(float[], float, float) Normalize a vector between the specified limits. public static void Normalize(float[] vector, float min, float max) Parameters vector float[] Vector to normalize, in-place. min float Minimum normalization range. max float Maximum normalization range."
  },
  "api/LibGameAI.Util.Neighborhood.html": {
    "href": "api/LibGameAI.Util.Neighborhood.html",
    "title": "Enum Neighborhood | LibGameAI",
    "keywords": "Enum Neighborhood Namespace LibGameAI.Util Assembly Util.dll Known types of neighborhood. public enum Neighborhood Extension Methods NeighborhoodExtensions.GetNeighborhood(Neighborhood, int) NeighborhoodExtensions.MaxNeighbors(Neighborhood, int) Fields Hexagonal = 2 Moore = 0 VonNeumann = 1"
  },
  "api/LibGameAI.Util.NeighborhoodExtensions.html": {
    "href": "api/LibGameAI.Util.NeighborhoodExtensions.html",
    "title": "Class NeighborhoodExtensions | LibGameAI",
    "keywords": "Class NeighborhoodExtensions Namespace LibGameAI.Util Assembly Util.dll Useful extension methods for processing neighborhoods. public static class NeighborhoodExtensions Inheritance object NeighborhoodExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetNeighborhood(Neighborhood, int) Returns a collection of relative positions constituting the neighborhood of the given neighborhood type and radius. public static IEnumerable<(int x, int y)> GetNeighborhood(this Neighborhood neighborhood, int radius) Parameters neighborhood Neighborhood Neighborhood type. radius int Neighborhood radius. Returns IEnumerable<(int x, int y)> A collection of relative positions constituting the neighborhood of the given neighborhood type and radius. Exceptions ArgumentException Thrown if the neighborhood type is unknown. HexNeighbors(int) Returns a collection of relative positions constituting the hexagonal neighborhood with the given radius. public static IEnumerable<(int x, int y)> HexNeighbors(int radius) Parameters radius int Neighborhood radius. Returns IEnumerable<(int x, int y)> A collection of relative positions constituting the hexagonal neighborhood with the given radius. MaxNeighbors(Neighborhood, int) Maximum number of neighbors for this neighborhood type and radius. public static int MaxNeighbors(this Neighborhood neighborhood, int radius) Parameters neighborhood Neighborhood Neighborhood type. radius int Neighborhood radius. Returns int Maximum number of neighbors for this neighborhood type and radius. Exceptions ArgumentException Thrown if the neighborhood type is unknown. MooreNeighbors(int) Returns a collection of relative positions constituting the Moore neighborhood with the given radius. public static IEnumerable<(int x, int y)> MooreNeighbors(int radius) Parameters radius int Neighborhood radius. Returns IEnumerable<(int x, int y)> A collection of relative positions constituting the Moore neighborhood with the given radius. VonNeumannNeighbors(int) Returns a collection of relative positions constituting the Von Neumann neighborhood with the given radius. public static IEnumerable<(int x, int y)> VonNeumannNeighbors(int radius) Parameters radius int Neighborhood radius. Returns IEnumerable<(int x, int y)> A collection of relative positions constituting the Von Neumann neighborhood with the given radius."
  },
  "api/LibGameAI.Util.ReadOnlyListSegment-1.html": {
    "href": "api/LibGameAI.Util.ReadOnlyListSegment-1.html",
    "title": "Struct ReadOnlyListSegment<T> | LibGameAI",
    "keywords": "Struct ReadOnlyListSegment<T> Namespace LibGameAI.Util Assembly Util.dll An efficient read-only wrapper for viewing a list segment as a list. public struct ReadOnlyListSegment<T> : IReadOnlyList<T>, IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable Type Parameters T The type of objects in the wrapped list. Implements IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ReadOnlyListSegment(IReadOnlyList<T>, int, int) Create a new read-only list segment. public ReadOnlyListSegment(IReadOnlyList<T> innerList, int offset, int count) Parameters innerList IReadOnlyList<T> Wrapped list. offset int Index, with respect to the wrapped list, of the first element in the list segment. count int Number of items in the list segment. Exceptions InvalidOperationException Thrown if innerList is null or if innerList has less than offset + count elements. Properties Count Number of items in the list segment. public readonly int Count { get; } Property Value int this[int] Gets the element at the specified index. public T this[int index] { get; } Parameters index int The zero-based index of the element to get. Property Value T The element at the specified index. Methods GetEnumerator() Returns an enumerator that iterates through the list segment. public IEnumerator<T> GetEnumerator() Returns IEnumerator<T> An enumerator that can be used to iterate through the list segment."
  },
  "api/LibGameAI.Util.RingList-1.html": {
    "href": "api/LibGameAI.Util.RingList-1.html",
    "title": "Class RingList<T> | LibGameAI",
    "keywords": "Class RingList<T> Namespace LibGameAI.Util Assembly Util.dll A ring list with a specified size. Adding more elements to the list over its size will silently drop older elements. public class RingList<T> : IReadOnlyList<T>, IReadOnlyCollection<T>, ICollection<T>, IEnumerable<T>, IEnumerable Type Parameters T The type of objects in the list. Inheritance object RingList<T> Implements IReadOnlyList<T> IReadOnlyCollection<T> ICollection<T> IEnumerable<T> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RingList(int) Create a new ring list with the specified capacity. public RingList(int capacity) Parameters capacity int Maximum capacity of the ring list. Properties Capacity Maximum number of element the list can contain at the same time. public int Capacity { get; } Property Value int Count Number of elements in the list. public int Count { get; } Property Value int IsReadOnly Is the list read-only (no, it's not). public bool IsReadOnly { get; } Property Value bool this[int] Gets or sets the element at the specified index. public T this[int index] { get; set; } Parameters index int The zero-based index of the element to get or set. Property Value T The element at the specified index. Exceptions IndexOutOfRangeException Thrown if index is greater than Count. Methods Add(T) Add an item to the end of the list. If list is already at maximum capacity, the first element will be silently removed. public void Add(T item) Parameters item T Item to add to the list. Clear() Clear list contents. public void Clear() Contains(T) Determines whether the list contains a specific value. public bool Contains(T item) Parameters item T The item to locate in the list. Returns bool true if item is found in the list; otherwise, false. CopyTo(T[], int) Copies the elements of the list to an array, starting at a particular array index. public void CopyTo(T[] array, int arrayIndex) Parameters array T[] The one-dimensional array that is the destination of the elements copied from the list. The array must have zero-based indexing. arrayIndex int The zero-based index in array at which copying begins. GetEnumerator() Returns an enumerator that iterates through the list elements. public IEnumerator<T> GetEnumerator() Returns IEnumerator<T> An enumerator that can be used to iterate through the list elements. Remove(T) Unsupported operation. public bool Remove(T item) Parameters item T The item that would be removed from the list if this operation was supported. Returns bool Never returns anything, always throws an exception. Exceptions InvalidOperationException This exception is always thrown."
  },
  "api/LibGameAI.Util.Stats.html": {
    "href": "api/LibGameAI.Util.Stats.html",
    "title": "Class Stats | LibGameAI",
    "keywords": "Class Stats Namespace LibGameAI.Util Assembly Util.dll public static class Stats Inheritance object Stats Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods NextNormalDouble(Func<double>) public static double NextNormalDouble(Func<double> nextUnifDouble) Parameters nextUnifDouble Func<double> Returns double NormalCDF(double, double, double) public static double NormalCDF(double x, double mean = 0, double std = 1) Parameters x double mean double std double Returns double"
  },
  "api/LibGameAI.Util.html": {
    "href": "api/LibGameAI.Util.html",
    "title": "Namespace LibGameAI.Util | LibGameAI",
    "keywords": "Namespace LibGameAI.Util Classes ClassManager<T> Singleton class used for finding and keeping a record of concrete classes of a given generic type. MMath Useful math functions. NeighborhoodExtensions Useful extension methods for processing neighborhoods. RingList<T> A ring list with a specified size. Adding more elements to the list over its size will silently drop older elements. Stats Structs ListPlusOneWrapper<T> An efficient wrapper for a list plus one element. ReadOnlyListSegment<T> An efficient read-only wrapper for viewing a list segment as a list. Enums Neighborhood Known types of neighborhood."
  },
  "dev.html": {
    "href": "dev.html",
    "title": "Development | LibGameAI",
    "keywords": "Development To do."
  },
  "examples.html": {
    "href": "examples.html",
    "title": "Usage examples | LibGameAI",
    "keywords": "Usage examples This page will be expanded in the future. For now, check out LibGameAI being used in these educational Game AI Prototypes."
  },
  "index.html": {
    "href": "index.html",
    "title": "LibGameAI | LibGameAI",
    "keywords": "LibGameAI LibGameAI is .NET Standard 2.1 library of AI algorithms for video games with a focus on education. The library is organized into several components, installable from NuGet or downloadable directly into your project. Documentation Decision trees Finite state machines N-grams Naive Bayes classifier Path finding algorithms PCG PRNG QRNG Util Status & Usage This is very much a work in progress, and should be considered to be at an alpha stage of development. This library is currently used in the educational Game AI Prototypes. Reference If you use or mention this software in your work, please cite the following reference: Fachada, N., Barreiros, F.F., Lopes, P., & Fonseca, M. (2023, August). Active Learning Prototypes for Teaching Game AI. In 2023 IEEE Conference on Games (CoG) (pp. TBD). IEEE. License MIT"
  }
}